{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to GraphStorage GraphStorage is a Java library for storing large-scale property graphs in secondary memory (HDD/SSD). It is built on top of RocksDB to provide a fast, persistent, and efficient storage layer. While this library was developed as a core component for the PathDB graph database engine, it is designed as a standalone module that can be integrated into any Java project requiring persistent graph data structures. Features Persistent Storage: Leverages RocksDB for a fast and durable key-value store, optimized for modern SSDs. Bulk Ingestion: Optimized methods for loading large .pgdf datasets quickly. Lazy Iteration: All collection-based queries (getNodeIterator, getNeighbours, etc.) return AutoCloseableIterables, ensuring low memory overhead by streaming data directly from disk. Query API: Provides methods for single-entity lookups (by ID), property-based searches, and neighbor retrieval. Schema & Metadata: Includes helpers to query graph-wide metadata (e.g., node/edge counts) and infer the graph's structure. Full Documentation This README serves as a brief overview. For a complete guide and detailed API definitions, please see the full documentation.","title":"Home"},{"location":"#welcome-to-graphstorage","text":"GraphStorage is a Java library for storing large-scale property graphs in secondary memory (HDD/SSD). It is built on top of RocksDB to provide a fast, persistent, and efficient storage layer. While this library was developed as a core component for the PathDB graph database engine, it is designed as a standalone module that can be integrated into any Java project requiring persistent graph data structures.","title":"Welcome to GraphStorage"},{"location":"#features","text":"Persistent Storage: Leverages RocksDB for a fast and durable key-value store, optimized for modern SSDs. Bulk Ingestion: Optimized methods for loading large .pgdf datasets quickly. Lazy Iteration: All collection-based queries (getNodeIterator, getNeighbours, etc.) return AutoCloseableIterables, ensuring low memory overhead by streaming data directly from disk. Query API: Provides methods for single-entity lookups (by ID), property-based searches, and neighbor retrieval. Schema & Metadata: Includes helpers to query graph-wide metadata (e.g., node/edge counts) and infer the graph's structure. Full Documentation This README serves as a brief overview. For a complete guide and detailed API definitions, please see the full documentation.","title":"Features"},{"location":"FullDoc/","text":"GraphStorage API Reference This document provides a detailed reference for the public API of the GraphStorage class. Lifecycle & Instantiation Methods for creating, opening, and closing a database instance. public static GraphStorage open(Path dbPath) Opens or creates a new database at the specified file system path. This is the main entry point for the library. Parameters: dbPath , the java.nio.file.Path to the directory where the database will be stored. Returns: A new GraphStorage instance, ready for use. Throws: GraphStorageException , If an error occurs while opening or creating the database (e.g., I/O error or RocksDB-level issue). import java.nio.file.Paths; try (GraphStorage db = GraphStorage.open(Paths.get(\"./my-graph-db\"))) { // Use the database instance System.out.println(\"Database is open.\"); } catch (GraphStorageException e) { e.printStackTrace(); } public void close() Closes the database connection and releases all underlying resources (including file handles and RocksDB instances). This method is part of the AutoCloseable interface and is called automatically when you use a try-with-resources block, which is the recommended practice. Parameters: None. Returns: void. Ingestion API Methods for bulk-loading data into the database, currently you can only use .pgdf files public void insertNodesByFile(String filepath) Performs a bulk ingestion of nodes from a specified data file. Parameters: filepath , A String representing the path to the node data file. Returns: void. Throws: GraphStorageException : If the file cannot be read or a database error occurs during ingestion. try (GraphStorage db = GraphStorage.open(Paths.get(\"./my-graph-db\"))) { db.insertNodesByFile(\"path/to/my_nodes.pgdf\"); } public void insertEdgesByFile(String filepath) Performs a bulk ingestion of edges from a specified data file. Parameters: filepath , A String representing the path to the edge data file. Returns: void. Throws: GraphStorageException , If the file cannot be read or a database error occurs during ingestion. try (GraphStorage db = GraphStorage.open(Paths.get(\"./my-graph-db\"))) { db.insertEdgesByFile(\"path/to/my_edges.pgdf\"); } Single Entity Queries Methods for retrieving a single, specific entity by its unique ID. public NodeBlob getNode(String nodeId) Retrieves a single node and its data given its unique ID. Parameters: nodeId , The unique ID of the node to retrieve. Returns: A NodeBlob object containing the node's label and properties, or null if no node with that ID is found. Throws: GraphStorageException , If a database read error occurs. NodeBlob node = db.getNode(\"user_123\"); if (node != null) { System.out.println(\"Label: \" + node.label); System.out.println(\"Name: \" + node.props.get(\"name\")); } public EdgeBlob getEdge(String edgeId) Retrieves a single edge and its data given its unique ID. Parameters: edgeId , The unique ID of the edge to retrieve. Returns: An EdgeBlob object containing the edge's label, source/target IDs, and properties, or null if no edge with that ID is found. Throws: GraphStorageException , If a database read error occurs. EdgeBlob edge = db.getEdge(\"rel_456\"); if (edge != null) { System.out.println(\"Label: \" + edge.label); System.out.println(edge.src + \" -> \" + edge.dst); } Iterator Queries Methods for querying multiple entities. These methods return lazy iterators for high performance and low memory usage. Important: Always Close Iterators All methods in this section return an AutoCloseableIterable . You must use them in a try-with-resources block to prevent resource leaks. public AutoCloseableIterable<NodeEntry> getNodeIterator() Returns a lazy iterator over all nodes in the database. Parameters: None. Returns: AutoCloseableIterable<GraphQueries.NodeEntry> . try (var nodes = db.getNodeIterator()) { for (var nodeEntry : nodes) { System.out.println(\"ID: \" + nodeEntry.id() + \", Label: \" + nodeEntry.blob().label); } } public AutoCloseableIterable<EdgeEntry> getEdgeIterator() Returns a lazy iterator over all edges in the database. Parameters: None. Returns: An AutoCloseableIterable<GraphQueries.EdgeEntry> . try (var edges = db.getEdgeIterator()) { for (var edgeEntry : edges) { System.out.println(\"ID: \" + edgeEntry.id() + \", Label: \" + edgeEntry.blob().label); } } public AutoCloseableIterable<EdgeEntry> getEdgeIteratorByLabel(String label) Returns a lazy iterator over all edges that have a specific label. Parameters: label , The exact edge label to filter by (e.g., \"KNOWS\"). Returns: An AutoCloseableIterable<GraphQueries.EdgeEntry> . try (var edges = db.getEdgeIteratorByLabel(\"KNOWS\")) { for (var edgeEntry : edges) { EdgeBlob edge = edgeEntry.blob(); System.out.println(edge.src + \" KNOWS \" + edge.dst); } } public AutoCloseableIterable<EdgeEntry> getNeighbours(String nodeId) Returns a lazy iterator over all neighboring edges (both incoming and outgoing) for a specific node. Parameters: nodeId , The unique ID of the central node. Returns: An AutoCloseableIterable<GraphQueries.EdgeEntry> . try (var neighbors = db.getNeighbours(\"user_123\")) { for (var edgeEntry : neighbors) { System.out.println(\"Found neighboring edge: \" + edgeEntry.id()); } } public AutoCloseableIterable<NodeEntry> getNodesByPropertyEquals(String propName, String propValue) Returns a lazy iterator over all nodes that have a specific property key matching a specific value. Parameters: propName , The name of the property (e.g., \"city\"). propValue , The exact value to match (e.g., \"London\"). Returns: An AutoCloseableIterable<GraphQueries.NodeEntry> . try (var nodes = db.getNodesByPropertyEquals(\"city\", \"London\")) { for (var nodeEntry : nodes) { System.out.println(\"Found node: \" + nodeEntry.id()); } } public AutoCloseableIterable<EdgeEntry> getEdgesByPropertyEquals(String propName, String propValue) Returns a lazy iterator over all edges that have a specific property key matching a specific value. Parameters: propName , The name of the property (e.g., \"weight\"). propValue : The exact value to match (e.g., \"10.5\"). Returns: An AutoCloseableIterable<GraphQueries.EdgeEntry> . try (var edges = db.getEdgesByPropertyEquals(\"weight\", \"10.5\")) { for (var edgeEntry : edges) { System.out.println(\"Found edge: \" + edgeEntry.id()); } } Metadata Queries Methods for retrieving metadata, counts, and schema information about the graph. public long getNodesQuantity() Gets the total number of nodes in the database. Parameters: None. Returns: A long representing the total node count. Throws: GraphStorageException , If a database read error occurs. long nodeCount = db.getNodesQuantity(); System.out.println(\"Total nodes: \" + nodeCount); public long getEdgesQuantity() Gets the total number of edges in the database. Parameters: None. Returns: A long representing the total edge count. Throws: GraphStorageException , If a database read error occurs. long edgeCount = db.getEdgesQuantity(); System.out.println(\"Total edges: \" + edgeCount); public Map<String, Long> getEdgesQuantityByLabel() Gets the total number of edges, grouped by their label. Parameters: None. Returns: A Map<String, Long> where the key is the label and the value is the count. Throws: GraphStorageException : If a database read error occurs. Map<String, Long> counts = db.getEdgesQuantityByLabel(); for (var entry : counts.entrySet()) { System.out.println(\"Label '\" + entry.getKey() + \"': \" + entry.getValue() + \" edges\"); } public Map<String, Set<String>> getNodesStructure() Retrieves the detected \"schema\" of the nodes. It returns a map where each key is a node label, and the value is a set of all property keys found on nodes with that label. Parameters: None. Returns: Map<String, Set<String>> (Map<Label, Set<PropertyKey>>) . Throws: GraphStorageException : If a database read error occurs. Map<String, Set<String>> nodeSchema = db.getNodesStructure(); // E.g., prints: \"Label 'User': [name, age, email]\" nodeSchema.forEach((label, props) -> { System.out.println(\"Label '\" + label + \"': \" + props); }); public Map<String, Set<String>> getEdgesStructure() Retrieves the detected \"schema\" of the edges. It returns a map where each key is an edge label, and the value is a set of all property keys found on edges with that label. Parameters: None. Returns: Map<String, Set<String>> (Map<Label, Set<PropertyKey>>) . Throws: GraphStorageException : If a database read error occurs. Map<String, Set<String>> edgeSchema = db.getEdgesStructure(); // E.g., prints: \"Label 'KNOWS': [since, weight]\" edgeSchema.forEach((label, props) -> { System.out.println(\"Label '\" + label + \"': \" + props); });","title":"Documentation"},{"location":"FullDoc/#graphstorage-api-reference","text":"This document provides a detailed reference for the public API of the GraphStorage class.","title":"GraphStorage API Reference"},{"location":"FullDoc/#lifecycle-instantiation","text":"Methods for creating, opening, and closing a database instance. public static GraphStorage open(Path dbPath) Opens or creates a new database at the specified file system path. This is the main entry point for the library. Parameters: dbPath , the java.nio.file.Path to the directory where the database will be stored. Returns: A new GraphStorage instance, ready for use. Throws: GraphStorageException , If an error occurs while opening or creating the database (e.g., I/O error or RocksDB-level issue). import java.nio.file.Paths; try (GraphStorage db = GraphStorage.open(Paths.get(\"./my-graph-db\"))) { // Use the database instance System.out.println(\"Database is open.\"); } catch (GraphStorageException e) { e.printStackTrace(); } public void close() Closes the database connection and releases all underlying resources (including file handles and RocksDB instances). This method is part of the AutoCloseable interface and is called automatically when you use a try-with-resources block, which is the recommended practice. Parameters: None. Returns: void.","title":"Lifecycle &amp; Instantiation"},{"location":"FullDoc/#ingestion-api","text":"Methods for bulk-loading data into the database, currently you can only use .pgdf files public void insertNodesByFile(String filepath) Performs a bulk ingestion of nodes from a specified data file. Parameters: filepath , A String representing the path to the node data file. Returns: void. Throws: GraphStorageException : If the file cannot be read or a database error occurs during ingestion. try (GraphStorage db = GraphStorage.open(Paths.get(\"./my-graph-db\"))) { db.insertNodesByFile(\"path/to/my_nodes.pgdf\"); } public void insertEdgesByFile(String filepath) Performs a bulk ingestion of edges from a specified data file. Parameters: filepath , A String representing the path to the edge data file. Returns: void. Throws: GraphStorageException , If the file cannot be read or a database error occurs during ingestion. try (GraphStorage db = GraphStorage.open(Paths.get(\"./my-graph-db\"))) { db.insertEdgesByFile(\"path/to/my_edges.pgdf\"); }","title":"Ingestion API"},{"location":"FullDoc/#single-entity-queries","text":"Methods for retrieving a single, specific entity by its unique ID. public NodeBlob getNode(String nodeId) Retrieves a single node and its data given its unique ID. Parameters: nodeId , The unique ID of the node to retrieve. Returns: A NodeBlob object containing the node's label and properties, or null if no node with that ID is found. Throws: GraphStorageException , If a database read error occurs. NodeBlob node = db.getNode(\"user_123\"); if (node != null) { System.out.println(\"Label: \" + node.label); System.out.println(\"Name: \" + node.props.get(\"name\")); } public EdgeBlob getEdge(String edgeId) Retrieves a single edge and its data given its unique ID. Parameters: edgeId , The unique ID of the edge to retrieve. Returns: An EdgeBlob object containing the edge's label, source/target IDs, and properties, or null if no edge with that ID is found. Throws: GraphStorageException , If a database read error occurs. EdgeBlob edge = db.getEdge(\"rel_456\"); if (edge != null) { System.out.println(\"Label: \" + edge.label); System.out.println(edge.src + \" -> \" + edge.dst); }","title":"Single Entity Queries"},{"location":"FullDoc/#iterator-queries","text":"Methods for querying multiple entities. These methods return lazy iterators for high performance and low memory usage. Important: Always Close Iterators All methods in this section return an AutoCloseableIterable . You must use them in a try-with-resources block to prevent resource leaks. public AutoCloseableIterable<NodeEntry> getNodeIterator() Returns a lazy iterator over all nodes in the database. Parameters: None. Returns: AutoCloseableIterable<GraphQueries.NodeEntry> . try (var nodes = db.getNodeIterator()) { for (var nodeEntry : nodes) { System.out.println(\"ID: \" + nodeEntry.id() + \", Label: \" + nodeEntry.blob().label); } } public AutoCloseableIterable<EdgeEntry> getEdgeIterator() Returns a lazy iterator over all edges in the database. Parameters: None. Returns: An AutoCloseableIterable<GraphQueries.EdgeEntry> . try (var edges = db.getEdgeIterator()) { for (var edgeEntry : edges) { System.out.println(\"ID: \" + edgeEntry.id() + \", Label: \" + edgeEntry.blob().label); } } public AutoCloseableIterable<EdgeEntry> getEdgeIteratorByLabel(String label) Returns a lazy iterator over all edges that have a specific label. Parameters: label , The exact edge label to filter by (e.g., \"KNOWS\"). Returns: An AutoCloseableIterable<GraphQueries.EdgeEntry> . try (var edges = db.getEdgeIteratorByLabel(\"KNOWS\")) { for (var edgeEntry : edges) { EdgeBlob edge = edgeEntry.blob(); System.out.println(edge.src + \" KNOWS \" + edge.dst); } } public AutoCloseableIterable<EdgeEntry> getNeighbours(String nodeId) Returns a lazy iterator over all neighboring edges (both incoming and outgoing) for a specific node. Parameters: nodeId , The unique ID of the central node. Returns: An AutoCloseableIterable<GraphQueries.EdgeEntry> . try (var neighbors = db.getNeighbours(\"user_123\")) { for (var edgeEntry : neighbors) { System.out.println(\"Found neighboring edge: \" + edgeEntry.id()); } } public AutoCloseableIterable<NodeEntry> getNodesByPropertyEquals(String propName, String propValue) Returns a lazy iterator over all nodes that have a specific property key matching a specific value. Parameters: propName , The name of the property (e.g., \"city\"). propValue , The exact value to match (e.g., \"London\"). Returns: An AutoCloseableIterable<GraphQueries.NodeEntry> . try (var nodes = db.getNodesByPropertyEquals(\"city\", \"London\")) { for (var nodeEntry : nodes) { System.out.println(\"Found node: \" + nodeEntry.id()); } } public AutoCloseableIterable<EdgeEntry> getEdgesByPropertyEquals(String propName, String propValue) Returns a lazy iterator over all edges that have a specific property key matching a specific value. Parameters: propName , The name of the property (e.g., \"weight\"). propValue : The exact value to match (e.g., \"10.5\"). Returns: An AutoCloseableIterable<GraphQueries.EdgeEntry> . try (var edges = db.getEdgesByPropertyEquals(\"weight\", \"10.5\")) { for (var edgeEntry : edges) { System.out.println(\"Found edge: \" + edgeEntry.id()); } }","title":"Iterator Queries"},{"location":"FullDoc/#metadata-queries","text":"Methods for retrieving metadata, counts, and schema information about the graph. public long getNodesQuantity() Gets the total number of nodes in the database. Parameters: None. Returns: A long representing the total node count. Throws: GraphStorageException , If a database read error occurs. long nodeCount = db.getNodesQuantity(); System.out.println(\"Total nodes: \" + nodeCount); public long getEdgesQuantity() Gets the total number of edges in the database. Parameters: None. Returns: A long representing the total edge count. Throws: GraphStorageException , If a database read error occurs. long edgeCount = db.getEdgesQuantity(); System.out.println(\"Total edges: \" + edgeCount); public Map<String, Long> getEdgesQuantityByLabel() Gets the total number of edges, grouped by their label. Parameters: None. Returns: A Map<String, Long> where the key is the label and the value is the count. Throws: GraphStorageException : If a database read error occurs. Map<String, Long> counts = db.getEdgesQuantityByLabel(); for (var entry : counts.entrySet()) { System.out.println(\"Label '\" + entry.getKey() + \"': \" + entry.getValue() + \" edges\"); } public Map<String, Set<String>> getNodesStructure() Retrieves the detected \"schema\" of the nodes. It returns a map where each key is a node label, and the value is a set of all property keys found on nodes with that label. Parameters: None. Returns: Map<String, Set<String>> (Map<Label, Set<PropertyKey>>) . Throws: GraphStorageException : If a database read error occurs. Map<String, Set<String>> nodeSchema = db.getNodesStructure(); // E.g., prints: \"Label 'User': [name, age, email]\" nodeSchema.forEach((label, props) -> { System.out.println(\"Label '\" + label + \"': \" + props); }); public Map<String, Set<String>> getEdgesStructure() Retrieves the detected \"schema\" of the edges. It returns a map where each key is an edge label, and the value is a set of all property keys found on edges with that label. Parameters: None. Returns: Map<String, Set<String>> (Map<Label, Set<PropertyKey>>) . Throws: GraphStorageException : If a database read error occurs. Map<String, Set<String>> edgeSchema = db.getEdgesStructure(); // E.g., prints: \"Label 'KNOWS': [since, weight]\" edgeSchema.forEach((label, props) -> { System.out.println(\"Label '\" + label + \"': \" + props); });","title":"Metadata Queries"},{"location":"FullExample/","text":"Workflow example This example demonstrates the complete workflow: ingesting data, running various queries, and fetching metadata. Example Data Files First, let's assume you have two files, nodes.pgdf and edges.pgdf, in your project's root directory. The ingestor expects these files to be in the .pgdf format. nodes.pgdf @id|@label|name|country user_101|User|Ana|Mexico user_102|User|Bob|USA user_103|User|Pedro|Chile edges.pgdf @id|@label|@dir|@out|@in|weight edge_50|KNOWS|T|user_101|user_102|0.8 edge_51|WORKS_WITH|T|user_103|user_101|0.2 Code example This single Java class performs all operations on the data defined above. import com.gdblab.graphstorage.GraphStorage; import com.gdblab.graphstorage.storage.EdgeBlob; import com.gdblab.graphstorage.storage.NodeBlob; import com.gdblab.graphstorage.storage.Utils.GraphStorageException; import java.nio.file.Path; import java.nio.file.Paths; public class FullDemo { public static void main(String[] args) { Path dbPath = Paths.get(\"./my-graph-db\"); try (GraphStorage db = GraphStorage.open(dbPath)) { System.out.println(\"Database opened successfully at: \" + dbPath.toAbsolutePath()); // INGEST DATA // This only needs to be run once. // You can comment this out after the first successful run. System.out.println(\"\\n--- Ingesting Data ---\"); try { db.insertNodesByFile(\"nodes.pgdf\"); db.insertEdgesByFile(\"edges.pgdf\"); System.out.println(\"Ingestion complete.\"); } catch (GraphStorageException e) { System.err.println(\"Ingestion failed: \" + e.getMessage()); } // SINGLE ENTITY QUERY (BY ID) System.out.println(\"\\n--- Query 1: Get Node 'user_101' ---\"); try { NodeBlob node = db.getNode(\"user_101\"); if (node != null) { System.out.println(\"Found node. Label: \" + node.label); System.out.println(\"Property 'name': \" + node.props.get(\"name\")); System.out.println(\"Property 'country': \" + node.props.get(\"country\")); } else { System.out.println(\"Node with ID 'user_101' not found.\"); } } catch (GraphStorageException e) { e.printStackTrace(); } // ITERATOR QUERY (BY PROPERTY) // Note: This must be in a try-with-resources block System.out.println(\"\\n--- Query 2: Find Nodes where 'country'='Chile' ---\"); try (var nodes = db.getNodesByPropertyEquals(\"country\", \"Chile\")) { for (var nodeEntry : nodes) { NodeBlob blob = nodeEntry.blob(); System.out.println(\" - Found Node ID: \" + nodeEntry.id()); System.out.println(\" Label: \" + blob.label); System.out.println(\" Name: \" + blob.props.get(\"name\")); } } catch (GraphStorageException e) { e.printStackTrace(); } // ITERATOR QUERY (NEIGHBORS) // This also MUST be in a try-with-resources block System.out.println(\"\\n--- Query 3: Get Neighbors of 'user_101' ---\"); try (var neighbors = db.getNeighbours(\"user_101\")) { for (var edgeEntry : neighbors) { EdgeBlob blob = edgeEntry.blob(); System.out.println(\" - Found Edge ID: \" + edgeEntry.id()); System.out.println(\" Label: \" + blob.label); System.out.println( String.format(\" %s --[%s]--> %s\", blob.src, blob.label, blob.dst) ); } } catch (GraphStorageException e) { e.printStackTrace(); } // METADATA QUERIES System.out.println(\"\\n--- Query 4: Graph Metadata ---\"); try { long nodeCount = db.getNodesQuantity(); long edgeCount = db.getEdgesQuantity(); System.out.println(\"Total Nodes: \" + nodeCount); System.out.println(\"Total Edges: \" + edgeCount); var edgesByLabel = db.getEdgesQuantityByLabel(); System.out.println(\"Edge Counts by Label:\"); edgesByLabel.forEach((label, count) -> { System.out.println(\" - \" + label + \": \" + count); }); } catch (GraphStorageException e) { e.printStackTrace(); } } catch (GraphStorageException e) { System.err.println(\"A critical error occurred with the database:\"); e.printStackTrace(); } } } you should get in your terminal: Database opened successfully at: /home/user/your_project/my-graph-db --- Ingesting Data --- Ingestion complete. --- Query 1: Get Node 'user_101' --- Found node. Label: User Property 'name': Ana Property 'country': Mexico --- Query 2: Find Nodes where 'country'='Chile' --- - Found Node ID: user_103 Label: User Name: Pedro --- Query 3: Get Neighbors of 'user_101' --- - Found Edge ID: edge_50 Label: KNOWS user_101 --[KNOWS]--> user_102 - Found Edge ID: edge_51 Label: WORKS_WITH user_103 --[WORKS_WITH]--> user_101 --- Query 4: Graph Metadata --- Total Nodes: 3 Total Edges: 2 Edge Counts by Label: - KNOWS: 1 - WORKS_WITH: 1","title":"Workflow Example"},{"location":"FullExample/#workflow-example","text":"This example demonstrates the complete workflow: ingesting data, running various queries, and fetching metadata.","title":"Workflow example"},{"location":"FullExample/#example-data-files","text":"First, let's assume you have two files, nodes.pgdf and edges.pgdf, in your project's root directory. The ingestor expects these files to be in the .pgdf format.","title":"Example Data Files"},{"location":"FullExample/#nodespgdf","text":"@id|@label|name|country user_101|User|Ana|Mexico user_102|User|Bob|USA user_103|User|Pedro|Chile","title":"nodes.pgdf"},{"location":"FullExample/#edgespgdf","text":"@id|@label|@dir|@out|@in|weight edge_50|KNOWS|T|user_101|user_102|0.8 edge_51|WORKS_WITH|T|user_103|user_101|0.2","title":"edges.pgdf"},{"location":"FullExample/#code-example","text":"This single Java class performs all operations on the data defined above. import com.gdblab.graphstorage.GraphStorage; import com.gdblab.graphstorage.storage.EdgeBlob; import com.gdblab.graphstorage.storage.NodeBlob; import com.gdblab.graphstorage.storage.Utils.GraphStorageException; import java.nio.file.Path; import java.nio.file.Paths; public class FullDemo { public static void main(String[] args) { Path dbPath = Paths.get(\"./my-graph-db\"); try (GraphStorage db = GraphStorage.open(dbPath)) { System.out.println(\"Database opened successfully at: \" + dbPath.toAbsolutePath()); // INGEST DATA // This only needs to be run once. // You can comment this out after the first successful run. System.out.println(\"\\n--- Ingesting Data ---\"); try { db.insertNodesByFile(\"nodes.pgdf\"); db.insertEdgesByFile(\"edges.pgdf\"); System.out.println(\"Ingestion complete.\"); } catch (GraphStorageException e) { System.err.println(\"Ingestion failed: \" + e.getMessage()); } // SINGLE ENTITY QUERY (BY ID) System.out.println(\"\\n--- Query 1: Get Node 'user_101' ---\"); try { NodeBlob node = db.getNode(\"user_101\"); if (node != null) { System.out.println(\"Found node. Label: \" + node.label); System.out.println(\"Property 'name': \" + node.props.get(\"name\")); System.out.println(\"Property 'country': \" + node.props.get(\"country\")); } else { System.out.println(\"Node with ID 'user_101' not found.\"); } } catch (GraphStorageException e) { e.printStackTrace(); } // ITERATOR QUERY (BY PROPERTY) // Note: This must be in a try-with-resources block System.out.println(\"\\n--- Query 2: Find Nodes where 'country'='Chile' ---\"); try (var nodes = db.getNodesByPropertyEquals(\"country\", \"Chile\")) { for (var nodeEntry : nodes) { NodeBlob blob = nodeEntry.blob(); System.out.println(\" - Found Node ID: \" + nodeEntry.id()); System.out.println(\" Label: \" + blob.label); System.out.println(\" Name: \" + blob.props.get(\"name\")); } } catch (GraphStorageException e) { e.printStackTrace(); } // ITERATOR QUERY (NEIGHBORS) // This also MUST be in a try-with-resources block System.out.println(\"\\n--- Query 3: Get Neighbors of 'user_101' ---\"); try (var neighbors = db.getNeighbours(\"user_101\")) { for (var edgeEntry : neighbors) { EdgeBlob blob = edgeEntry.blob(); System.out.println(\" - Found Edge ID: \" + edgeEntry.id()); System.out.println(\" Label: \" + blob.label); System.out.println( String.format(\" %s --[%s]--> %s\", blob.src, blob.label, blob.dst) ); } } catch (GraphStorageException e) { e.printStackTrace(); } // METADATA QUERIES System.out.println(\"\\n--- Query 4: Graph Metadata ---\"); try { long nodeCount = db.getNodesQuantity(); long edgeCount = db.getEdgesQuantity(); System.out.println(\"Total Nodes: \" + nodeCount); System.out.println(\"Total Edges: \" + edgeCount); var edgesByLabel = db.getEdgesQuantityByLabel(); System.out.println(\"Edge Counts by Label:\"); edgesByLabel.forEach((label, count) -> { System.out.println(\" - \" + label + \": \" + count); }); } catch (GraphStorageException e) { e.printStackTrace(); } } catch (GraphStorageException e) { System.err.println(\"A critical error occurred with the database:\"); e.printStackTrace(); } } } you should get in your terminal: Database opened successfully at: /home/user/your_project/my-graph-db --- Ingesting Data --- Ingestion complete. --- Query 1: Get Node 'user_101' --- Found node. Label: User Property 'name': Ana Property 'country': Mexico --- Query 2: Find Nodes where 'country'='Chile' --- - Found Node ID: user_103 Label: User Name: Pedro --- Query 3: Get Neighbors of 'user_101' --- - Found Edge ID: edge_50 Label: KNOWS user_101 --[KNOWS]--> user_102 - Found Edge ID: edge_51 Label: WORKS_WITH user_103 --[WORKS_WITH]--> user_101 --- Query 4: Graph Metadata --- Total Nodes: 3 Total Edges: 2 Edge Counts by Label: - KNOWS: 1 - WORKS_WITH: 1","title":"Code example"},{"location":"Get_Started/","text":"Get started with GraphStorage Welcome to GraphStorage, an on-disk property graph storage library. This guide will walk you through adding the library to your project, opening a database, ingesting data from files, and performing basic queries. Prerequisites Java 17 or higher. Maven. Project Setup (Maven) First you need to clone the github repo . git clone https://github.com/dbgutalca/graph-storage cd graph-storage To use GraphStorage in your Maven project, you must first install the library to your local repository. Run the following command in the graph-storage directory: mvn install Once installed, you can add GraphStorage as a dependency in your other project's pom.xml: <dependency> <groupId>com.gdblab.graphstorage</groupId> <artifactId>graphstorage</artifactId> <version>1.0-SNAPSHOT</version> </dependency> Opening and Closing the Database The main entry point is the GraphStorage class. It implements AutoCloseable, so you should always use it within a try-with-resources block. This ensures that the database connection (and underlying RocksDB resources) are closed properly. import com.gdblab.graphstorage.GraphStorage; import com.gdblab.graphstorage.storage.Utils.GraphStorageException; import java.nio.file.Path; import java.nio.file.Paths; public class App { public static void main(String[] args) { // Define the path where the database will be stored Path dbPath = Paths.get(\"./my-graph-db\"); try (GraphStorage db = GraphStorage.open(dbPath)) { // ... your database interaction code goes here ... System.out.println(\"Database opened successfully at: \" + dbPath.toAbsolutePath()); } catch (GraphStorageException e) { System.err.println(\"Error opening or using the database:\"); e.printStackTrace(); } } } Ingesting Data GraphStorage is optimized for bulk ingesting data from .pgdf files. Use the insertNodesByFile and insertEdgesByFile methods. try (GraphStorage db = GraphStorage.open(dbPath)) { System.out.println(\"Ingesting nodes...\"); db.insertNodesByFile(\"nodes.pgdf\"); System.out.println(\"Ingesting edges...\"); db.insertEdgesByFile(\"edges.pgdf\"); System.out.println(\"Ingestion complete.\"); } Querying Data The API provides two main ways to query: fetching single entities by ID and getting lazy iterators for collections of entities. The query methods return NodeBlob and EdgeBlob objects, which contain public fields for easy data access. Single Entity Queries You can get a specific node or edge if you know its unique ID. import com.gdblab.graphstorage.storage.NodeBlob; import com.gdblab.graphstorage.storage.EdgeBlob; //... // ... inside the try-with-resources block ... try { // Get a single node by its ID NodeBlob node = db.getNode(\"user_101\"); if (node != null) { System.out.println(\"Found node. Label: \" + node.label); // Access properties directly from the 'props' map System.out.println(\"Property 'name': \" + node.props.get(\"name\")); } else { System.out.println(\"Node with ID 'user_101' not found.\"); } // Get a single edge by its ID EdgeBlob edge = db.getEdge(\"edge_50\"); if (edge != null) { System.out.println(\"Found edge. Label: \" + edge.label); System.out.println(\"Source: \" + edge.src); System.out.println(\"Target: \" + edge.dst); } } catch (GraphStorageException e) { e.printStackTrace(); } Iterator Queries For queries that return multiple results (like neighbors, nodes by property, or all nodes), the API returns an AutoCloseableIterable. This is important! You must always use these iterators within a try-with-resources block to prevent resource leaks. The iterator returns NodeEntry or EdgeEntry objects. Use the .id() method to get the ID and the .blob() method to get the NodeBlob or EdgeBlob. // Example: Get all neighbors of node \"user_101\" System.out.println(\"Neighbors of 'user_101':\"); try (var neighbors = db.getNeighbours(\"user_101\")) { for (var edgeEntry : neighbors) { EdgeBlob blob = edgeEntry.blob(); // Get the EdgeBlob System.out.println(\" - Edge ID: \" + edgeEntry.id()); System.out.println(\" Label: \" + blob.label); System.out.println(\" Source: \" + blob.src); System.out.println(\" Target: \" + blob.dst); System.out.println(\" Weight: \" + blob.props.get(\"weight\")); // Access props } } catch (GraphStorageException e) { e.printStackTrace(); } // Example: Find nodes by a specific property System.out.println(\"Nodes with property 'country'='Chile':\"); try (var nodes = db.getNodesByPropertyEquals(\"country\", \"Chile\")) { for (var nodeEntry : nodes) { NodeBlob blob = nodeEntry.blob(); // Get the NodeBlob System.out.println(\" - Node ID: \" + nodeEntry.id()); System.out.println(\" Label: \" + blob.label); System.out.println(\" Name: \" + blob.props.get(\"name\")); } } catch (GraphStorageException e) { e.printStackTrace(); } Querying Metadata You can quickly retrieve counts and other schema-related information. try { long nodeCount = db.getNodesQuantity(); long edgeCount = db.getEdgesQuantity(); System.out.println(\"Graph Metadata\"); System.out.println(\"Total Nodes: \" + nodeCount); System.out.println(\"Total Edges: \" + edgeCount); var edgesByLabel = db.getEdgesQuantityByLabel(); System.out.println(\"Edge Counts by Label:\"); edgesByLabel.forEach((label, count) -> { System.out.println(\" - \" + label + \": \" + count); }); } catch (GraphStorageException e) { e.printStackTrace(); }","title":"Get Started"},{"location":"Get_Started/#get-started-with-graphstorage","text":"Welcome to GraphStorage, an on-disk property graph storage library. This guide will walk you through adding the library to your project, opening a database, ingesting data from files, and performing basic queries.","title":"Get started with GraphStorage"},{"location":"Get_Started/#prerequisites","text":"Java 17 or higher. Maven.","title":"Prerequisites"},{"location":"Get_Started/#project-setup-maven","text":"First you need to clone the github repo . git clone https://github.com/dbgutalca/graph-storage cd graph-storage To use GraphStorage in your Maven project, you must first install the library to your local repository. Run the following command in the graph-storage directory: mvn install Once installed, you can add GraphStorage as a dependency in your other project's pom.xml: <dependency> <groupId>com.gdblab.graphstorage</groupId> <artifactId>graphstorage</artifactId> <version>1.0-SNAPSHOT</version> </dependency>","title":"Project Setup (Maven)"},{"location":"Get_Started/#opening-and-closing-the-database","text":"The main entry point is the GraphStorage class. It implements AutoCloseable, so you should always use it within a try-with-resources block. This ensures that the database connection (and underlying RocksDB resources) are closed properly. import com.gdblab.graphstorage.GraphStorage; import com.gdblab.graphstorage.storage.Utils.GraphStorageException; import java.nio.file.Path; import java.nio.file.Paths; public class App { public static void main(String[] args) { // Define the path where the database will be stored Path dbPath = Paths.get(\"./my-graph-db\"); try (GraphStorage db = GraphStorage.open(dbPath)) { // ... your database interaction code goes here ... System.out.println(\"Database opened successfully at: \" + dbPath.toAbsolutePath()); } catch (GraphStorageException e) { System.err.println(\"Error opening or using the database:\"); e.printStackTrace(); } } }","title":"Opening and Closing the Database"},{"location":"Get_Started/#ingesting-data","text":"GraphStorage is optimized for bulk ingesting data from .pgdf files. Use the insertNodesByFile and insertEdgesByFile methods. try (GraphStorage db = GraphStorage.open(dbPath)) { System.out.println(\"Ingesting nodes...\"); db.insertNodesByFile(\"nodes.pgdf\"); System.out.println(\"Ingesting edges...\"); db.insertEdgesByFile(\"edges.pgdf\"); System.out.println(\"Ingestion complete.\"); }","title":"Ingesting Data"},{"location":"Get_Started/#querying-data","text":"The API provides two main ways to query: fetching single entities by ID and getting lazy iterators for collections of entities. The query methods return NodeBlob and EdgeBlob objects, which contain public fields for easy data access.","title":"Querying Data"},{"location":"Get_Started/#single-entity-queries","text":"You can get a specific node or edge if you know its unique ID. import com.gdblab.graphstorage.storage.NodeBlob; import com.gdblab.graphstorage.storage.EdgeBlob; //... // ... inside the try-with-resources block ... try { // Get a single node by its ID NodeBlob node = db.getNode(\"user_101\"); if (node != null) { System.out.println(\"Found node. Label: \" + node.label); // Access properties directly from the 'props' map System.out.println(\"Property 'name': \" + node.props.get(\"name\")); } else { System.out.println(\"Node with ID 'user_101' not found.\"); } // Get a single edge by its ID EdgeBlob edge = db.getEdge(\"edge_50\"); if (edge != null) { System.out.println(\"Found edge. Label: \" + edge.label); System.out.println(\"Source: \" + edge.src); System.out.println(\"Target: \" + edge.dst); } } catch (GraphStorageException e) { e.printStackTrace(); }","title":"Single Entity Queries"},{"location":"Get_Started/#iterator-queries","text":"For queries that return multiple results (like neighbors, nodes by property, or all nodes), the API returns an AutoCloseableIterable. This is important! You must always use these iterators within a try-with-resources block to prevent resource leaks. The iterator returns NodeEntry or EdgeEntry objects. Use the .id() method to get the ID and the .blob() method to get the NodeBlob or EdgeBlob. // Example: Get all neighbors of node \"user_101\" System.out.println(\"Neighbors of 'user_101':\"); try (var neighbors = db.getNeighbours(\"user_101\")) { for (var edgeEntry : neighbors) { EdgeBlob blob = edgeEntry.blob(); // Get the EdgeBlob System.out.println(\" - Edge ID: \" + edgeEntry.id()); System.out.println(\" Label: \" + blob.label); System.out.println(\" Source: \" + blob.src); System.out.println(\" Target: \" + blob.dst); System.out.println(\" Weight: \" + blob.props.get(\"weight\")); // Access props } } catch (GraphStorageException e) { e.printStackTrace(); } // Example: Find nodes by a specific property System.out.println(\"Nodes with property 'country'='Chile':\"); try (var nodes = db.getNodesByPropertyEquals(\"country\", \"Chile\")) { for (var nodeEntry : nodes) { NodeBlob blob = nodeEntry.blob(); // Get the NodeBlob System.out.println(\" - Node ID: \" + nodeEntry.id()); System.out.println(\" Label: \" + blob.label); System.out.println(\" Name: \" + blob.props.get(\"name\")); } } catch (GraphStorageException e) { e.printStackTrace(); }","title":"Iterator Queries"},{"location":"Get_Started/#querying-metadata","text":"You can quickly retrieve counts and other schema-related information. try { long nodeCount = db.getNodesQuantity(); long edgeCount = db.getEdgesQuantity(); System.out.println(\"Graph Metadata\"); System.out.println(\"Total Nodes: \" + nodeCount); System.out.println(\"Total Edges: \" + edgeCount); var edgesByLabel = db.getEdgesQuantityByLabel(); System.out.println(\"Edge Counts by Label:\"); edgesByLabel.forEach((label, count) -> { System.out.println(\" - \" + label + \": \" + count); }); } catch (GraphStorageException e) { e.printStackTrace(); }","title":"Querying Metadata"}]}